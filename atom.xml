<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Waverley</title>
  <subtitle>风一样的程序员</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.waverley.me/"/>
  <updated>2017-06-08T14:20:08.000Z</updated>
  <id>http://www.waverley.me/</id>
  
  <author>
    <name>威风凛凛</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FreeBSD中的sysctl函数</title>
    <link href="http://www.waverley.me/2017/05/10/FreeBSD%E4%B8%AD%E7%9A%84sysctl%E5%87%BD%E6%95%B0/"/>
    <id>http://www.waverley.me/2017/05/10/FreeBSD中的sysctl函数/</id>
    <published>2017-05-10T15:12:00.000Z</published>
    <updated>2017-06-08T14:20:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>sysctl函数在unix类系统中有着至关重要的作用，可以用来获取或者设置kernel状态。</blockquote>

<p>FreeBSD中sysctl家族的函数定义：</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/sysctl.h&gt;

int
sysctl(const int *name, u_int namelen, void *oldp, size_t *oldlenp,
const void *newp, size_t newlen);

int
sysctlbyname(const char *name, void *oldp, size_t *oldlenp,
const void *newp, size_t newlen);

int
sysctlnametomib(const char *name, int *mibp, size_t *sizep);
</code></pre><a id="more"></a>
<p>在sysctl函数参数中，name和namelen用来表明内核参数ID；oldp和oldlenp用来存储当前内核参数的值；而newp和newlen则用来设置新的内核参数值。如果不需要的话，可以把相应的值置成NULL。<br>看一下sysctlbyname的实现：</p>
<pre><code>int
sysctlbyname(const char *name, void *oldp, size_t *oldlenp,
    const void *newp, size_t newlen)
{
    int real_oid[CTL_MAXNAME+2];
    size_t oidlen;

    oidlen = sizeof(real_oid) / sizeof(int);
    if (sysctlnametomib(name, real_oid, &amp;oidlen) &lt; 0)
        return (-1);
    return (sysctl(real_oid, oidlen, oldp, oldlenp, newp, newlen));
}
</code></pre><p>可以看到，sysctlbyname首先通过sysctlnametomib获得真正的ID，接着调用sysctl完成想要的工作。</p>
<p>参考资料：<br><a href="https://www.freebsd.org/cgi/man.cgi?sysctl%283%29" target="_blank" rel="external">SYSCTL(3)</a>;<br><a href="http://www.cs.unc.edu/~jeffay/dirt/FAQ/sysctl.html" target="_blank" rel="external">Grokking SYSCTL and the Art of Smashing Kernel Variables</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;sysctl函数在unix类系统中有着至关重要的作用，可以用来获取或者设置kernel状态。&lt;/blockquote&gt;

&lt;p&gt;FreeBSD中sysctl家族的函数定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/sysctl.h&amp;gt;

int
sysctl(const int *name, u_int namelen, void *oldp, size_t *oldlenp,
const void *newp, size_t newlen);

int
sysctlbyname(const char *name, void *oldp, size_t *oldlenp,
const void *newp, size_t newlen);

int
sysctlnametomib(const char *name, int *mibp, size_t *sizep);
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="技术总结" scheme="http://www.waverley.me/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="FreeBSD" scheme="http://www.waverley.me/tags/FreeBSD/"/>
    
      <category term="C语言" scheme="http://www.waverley.me/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>LIBGUESTFS分析介绍</title>
    <link href="http://www.waverley.me/2017/04/14/LIBGUESTFS%E5%88%86%E6%9E%90%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.waverley.me/2017/04/14/LIBGUESTFS分析介绍/</id>
    <published>2017-04-14T14:12:00.000Z</published>
    <updated>2017-06-08T14:15:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>Libguestfs 是一套能够访问并修改虚机磁盘镜像的工具，可以用来查看编辑虚拟机磁盘内部文件，监控虚拟机的磁盘使用情况、创建虚机磁盘等。</blockquote>

<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>Libguestfs——tools for accessing and modifying virtual machine disk images.<br>Libguestfs 是一套能够访问并修改虚机磁盘镜像的工具，可以用来查看编辑虚拟机磁盘内部文件，修改虚拟机内的脚本、监控虚拟机的磁盘使用情况、创建虚机磁盘等待，libguestfs能够访问任何虚机磁盘，并且不需要root权限，且有多层次的防御攻击虚机磁盘镜像的功能；它还可以访问远程机器或者CDs/USB上的磁盘镜像等。<br>Libguestfs从2009年持续开发到现在，有很丰富详细的使用手册，已经有很多应用成功的用户或项目，比如openstack。Libguestfs是一个C语言库，并且绑定十多种别的语言；开源KVM中的virt-builder、virt-install、virt-edit、virt-format、virt-inspector、virt-p2v、guestmount等一系列工具都是基于libguestfs库API来实现的。<br>官方网址：<a href="http://libguestfs.org/" target="_blank" rel="external">http://libguestfs.org/</a><br>开源代码：git clone git://github.com/libguestfs/libguestfs.git<br><a id="more"></a></p>
<h2 id="2-openstack如何部署虚机的？"><a href="#2-openstack如何部署虚机的？" class="headerlink" title="2 openstack如何部署虚机的？"></a>2 openstack如何部署虚机的？</h2><h2 id="2-1-openstack提供修改虚机磁盘镜像的方法"><a href="#2-1-openstack提供修改虚机磁盘镜像的方法" class="headerlink" title="2.1 openstack提供修改虚机磁盘镜像的方法"></a>2.1 openstack提供修改虚机磁盘镜像的方法</h2><p>openstack官网共提供了4种方法来修改虚机磁盘镜像：guestfish、guestmount、virt-*tools、nbd四种；其中前三种都是基于libguestfs库来实现的，第四种nbd正是CAS使用的方法。<br><img src="http://waverley.me/assets/blogImg/libguestfs2.png" alt="此处输入图片的描述"><br>然而，openstack已经不推荐使用nbd了，而是推荐使用基于libguestfs库的方法，实际代码中也是这么做的；<br>推荐的理由是：nbd直接将guest镜像挂载到host文件系统的方式是存在安全风险的，而libguestfs却可以提供至少两层防护；</p>
<h2 id="2-2-nbd方式的安全隐患"><a href="#2-2-nbd方式的安全隐患" class="headerlink" title="2.2 nbd方式的安全隐患"></a>2.2 nbd方式的安全隐患</h2><p>这里有一篇介绍nbd的安全隐患的文章：<br><a href="https://www.berrange.com/posts/2013/02/20/a-reminder-why-you-should-never-mount-guest-disk-images-on-the-host-os/" target="_blank" rel="external">https://www.berrange.com/posts/2013/02/20/a-reminder-why-you-should-never-mount-guest-disk-images-on-the-host-os/</a><br>当用nbd直接挂载文件系统时，VFS的一些漏洞可能被攻击者利用而成为一个恶意的文件系统；主要有两方面原因：<br>1、    在内核中有很多文件系统驱动程序，但是他们有很多程序很少被使用，开发人员也很少去关注这些代码；linux用户空间可以帮助潜在的攻击者识别文件系统的类型，并且选择一些恶意的文件系统程序；<br>2、    一个内核级漏洞就像一个本地root漏洞，可以给潜在的攻击者提供访问系统硬件的权限。</p>
<h2 id="2-3-Libguestfs的安全防护"><a href="#2-3-Libguestfs的安全防护" class="headerlink" title="2.3 Libguestfs的安全防护"></a>2.3 Libguestfs的安全防护</h2><p>Libguestfs可以通过创建虚机，在里面执行所有的文件系统操作的方式来阻止这种潜在的攻击；因此，即时攻击者利用VFS漏洞入侵到guest内核，他也必须突破虚机和secure virtualization后，才可能入侵到主机OS。<br>Libguestfs提供了一个分层的方法来隔离入侵：<a href="http://libguestfs.org/guestfs-security.1.html" target="_blank" rel="external">http://libguestfs.org/guestfs-security.1.html</a></p>
<pre><code>  untrusted filesystem
--------------------------------------
  appliance kernel
--------------------------------------
  qemu process running as non-root
--------------------------------------
  sVirt [if using libvirt + SELinux]
--------------------------------------
  host kernel
</code></pre><p>我们用libguestfs启动qemu虚机时，往往是作为non-root用户运行的。入侵者首先需要写一个文件系统入侵application kernel，然后入侵qemu虚拟化程序或者libguestfs协议，最后还要获取入侵host kernel的root权限。另外，如果再使用了libvirt和SELinux，sVirt 将进一步限制qemu进程。这样就大大增加了入侵的难度。<br>我们用libguestfs启动qemu虚机时，往往是作为non-root用户运行的。入侵者首先需要写一个文件系统入侵application kernel，然后入侵qemu虚拟化程序或者libguestfs协议，最后还要获取入侵host kernel的root权限。另外，如果再使用了libvirt和SELinux，sVirt 将进一步限制qemu进程。这样就大大增加了入侵的难度。</p>
<h2 id="3-Libguestfs实现原理"><a href="#3-Libguestfs实现原理" class="headerlink" title="3 Libguestfs实现原理"></a>3 Libguestfs实现原理</h2><h2 id="3-1-Libguestfs组成"><a href="#3-1-Libguestfs组成" class="headerlink" title="3.1 Libguestfs组成"></a>3.1 Libguestfs组成</h2><p>Libguestfs主要有三大部分：guestfsd、guestfs-lib、guestfish。其中guestfsd是一个daemon，libguestfs是一个lib，guestfish是一个命令行工具。<br>Guestfsd是一个daemon，但是它不是运行在host的daemon，而是运行在guest上，libguestfs首先用febootstrap和febootstrap-supermin-helper两个工具将host中的kernel，一些modules，配置文件和一些工具package重新组合到一起，然后在后台启动一个qemu进程读取这个有febootstrap工具链生成的image。在qemu启动的guest里运行guestfsd，guestfsd通过socket和host进行通信，之间建立了一个通信协议，它可以通过socket接受来自host端guestfs-lib写到socket的数据，guestfsd通过分析接收到的数据，进而执行相应的do<em>*操作，do</em><em>操作实际上是对guest端普通命令的一些封装，如果想实现一个NEW API，只要在guestfsd里用相应的do_</em>对普通命令进行封装即可，然后将这个普通命令程序通过febootstrap打包到qemu启动时读取的image中。<br>Guestfs-lib是一个库，它实现了一些libguestfs的库函数——guestfs_*。这些库函数向socket发送相应的数据，数据就会被guest端的guestfsd接收到，进而分析索要执行的操作。<br>Guestfish是对guestfs-lib接口函数的一些应用，guestfish的命令都是通过调用guestfs-lib的库函数来实现的。<br>因此，在使用libguestfs的时候，可以使用guestfish这样的命令行工具，也可以直接在程序（包括c，java，python等）中调用guestfs-lib实现的库函数。</p>
<h2 id="3-2-Guestfish原理"><a href="#3-2-Guestfish原理" class="headerlink" title="3.2 Guestfish原理"></a>3.2 Guestfish原理</h2><p>Guestfish –a vm.img 启动的进程，交互命令行是main program，当运行run时，会创建一个child process，在child process中，qemu运行一个成为appliance的小虚拟机。创建子进程是由guest_launch函数完成的。在appliance中，运行了linux kernel和一系列用户空间工具（LVM,ext2等），以及guestfsd。main process中的libguestfs和这个guestfsd通过RPC进行交互。由child process的kernel来操作vm.img。</p>
<p><img src="http://waverley.me/assets/blogImg/libguestfs3.png" alt="此处输入图片的描述"><br>以下为libguestfs启动的qemu进程：</p>
<pre><code>/usr/bin/kvm -global virtio-blk-pci.scsi=off -nodefconfig -enable-fips -nodefaults -display none -machine accel=kvm:tcg -cpu host -m 500 -no-reboot -rtc driftfix=slew -no-hpet -global kvm-pit.lost_tick_policy=discard -kernel /usr/local/lib/guestfs/appliance/kernel -initrd /usr/local/lib/guestfs/appliance/initrd -object rng-random,filename=/dev/urandom,id=rng0 -device virtio-rng-pci,rng=rng0 -device virtio-scsi-pci,id=scsi -drive file=/vms/images/win2003_r2_sp2_x64_base.img,cache=writeback,format=qcow2,id=hd0,if=none -device scsi-hd,drive=hd0 -drive file=/tmp/libguestfsdLLZTJ/overlay1,cache=unsafe,format=qcow2,id=hd1,if=none -device scsi-hd,drive=hd1 -drive file=/usr/local/lib/guestfs/appliance/root,snapshot=on,id=appliance,cache=unsafe,if=none,format=raw -device scsi-hd,drive=appliance -device virtio-serial-pci -serial stdio -chardev socket,path=/tmp/libguestfsIhONsg/guestfsd.sock,id=channel0 -device virtserialport,chardev=channel0,name=org.libguestfs.channel.0 -append panic=1 console=ttyS0 edd=off udevtimeout=6000 udev.event-timeout=6000 no_timer_check printk.time=1 cgroup_disable=memory usbcore.nousb cryptomgr.notests tsc=reliable 8250.nr_uarts=1 root=/dev/sdc selinux=0 quiet TERM=linux
</code></pre><h2 id="3-3-并行处理"><a href="#3-3-并行处理" class="headerlink" title="3.3 并行处理"></a>3.3 并行处理</h2><p>Libguestfs应用是IO绑定的，可以并行运行多个appliances。假设有充足的内存，1个appliance和多个appliances之间的时间性能仅仅有细微的差别。<br>在一个2核（4线程），16G内存的物理机上进行测试，下图展示了1个到20个appliances并行运行时良好的时间性能表现：<br><img src="http://waverley.me/assets/blogImg/libguestfs4.png" alt="此处输入图片的描述"><br>从表中可以看出，大量部署虚机时，可以并行部署3台，与运行单个appliance的时间性能几乎是一样的，可以大大节约部署的时间。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Libguestfs 是一套能够访问并修改虚机磁盘镜像的工具，可以用来查看编辑虚拟机磁盘内部文件，监控虚拟机的磁盘使用情况、创建虚机磁盘等。&lt;/blockquote&gt;

&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h2&gt;&lt;p&gt;Libguestfs——tools for accessing and modifying virtual machine disk images.&lt;br&gt;Libguestfs 是一套能够访问并修改虚机磁盘镜像的工具，可以用来查看编辑虚拟机磁盘内部文件，修改虚拟机内的脚本、监控虚拟机的磁盘使用情况、创建虚机磁盘等待，libguestfs能够访问任何虚机磁盘，并且不需要root权限，且有多层次的防御攻击虚机磁盘镜像的功能；它还可以访问远程机器或者CDs/USB上的磁盘镜像等。&lt;br&gt;Libguestfs从2009年持续开发到现在，有很丰富详细的使用手册，已经有很多应用成功的用户或项目，比如openstack。Libguestfs是一个C语言库，并且绑定十多种别的语言；开源KVM中的virt-builder、virt-install、virt-edit、virt-format、virt-inspector、virt-p2v、guestmount等一系列工具都是基于libguestfs库API来实现的。&lt;br&gt;官方网址：&lt;a href=&quot;http://libguestfs.org/&quot;&gt;http://libguestfs.org/&lt;/a&gt;&lt;br&gt;开源代码：git clone git://github.com/libguestfs/libguestfs.git&lt;br&gt;
    
    </summary>
    
      <category term="技术总结" scheme="http://www.waverley.me/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C语言" scheme="http://www.waverley.me/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://www.waverley.me/tags/Python/"/>
    
      <category term="Openstack" scheme="http://www.waverley.me/tags/Openstack/"/>
    
      <category term="Libguestfs" scheme="http://www.waverley.me/tags/Libguestfs/"/>
    
  </entry>
  
  <entry>
    <title>获取linux系统CPU实时利用率</title>
    <link href="http://www.waverley.me/2017/04/02/%E8%8E%B7%E5%8F%96linux%E7%B3%BB%E7%BB%9FCPU%E5%AE%9E%E6%97%B6%E5%88%A9%E7%94%A8%E7%8E%87/"/>
    <id>http://www.waverley.me/2017/04/02/获取linux系统CPU实时利用率/</id>
    <published>2017-04-02T15:43:00.000Z</published>
    <updated>2017-06-08T14:03:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>在Linux系统中，CPU时间的分配信息保存在/proc/stat文件中，我们就可以从这个文件中读取原始数据，然后计算出最终的CPU利用率的。</blockquote>

<p>在Linux系统中，CPU时间的分配信息保存在/proc/stat文件中，我们就可以从这个文件中读取原始数据，然后计算出最终的CPU利用率的。这个文件的一般格式如下所示：</p>
<pre><code>[root@localhost ~]# cat /proc/stat
cpu  245501 20040 134027 122597803 39715 23822 74062 0
cpu0 96705 11277 84622 61249161 31399 23283 70496 0
cpu1 148795 8762 49405 61348642 8316 538 3566 0
intr 636408939 615480120 9 0 0 4 0 4 0 1 0 85 0 73 0 1844999 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 481644 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 16401031 0 0 0 0 0 0 0 2054028 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 146941 0 0 0 0 0 0 0 0 0 0 0 0 0
ctxt 30181583
btime 1488951210
processes 431551
procs_running 1
procs_blocked 0
</code></pre><a id="more"></a>
<p>文件的前几行记录了每个CPU核心的在各种状态下分配的时间片（单位是Jiffies，一般为0.01s），这些数据是从CPU加电到当前的累计值。常用的监控软件（例如top等）就是利用/proc/stat里面的这些数据计算CPU利用率的。</p>
<p>不同版本的linux /proc/stat文件内容有略微差异，各列参数说明如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>User(1)</td>
<td>从系统启动开始累积到当前时刻，处于用户态的运行时间，不包含nice值为负进程；</td>
</tr>
<tr>
<td>Nice(2)</td>
<td>从系统启动开始累积到当前时刻，nice值为负的进程所占用的CPU时间；</td>
</tr>
<tr>
<td>System(3)</td>
<td>从系统启动开始累积到当前时刻，处于和心态的运行时间;</td>
</tr>
<tr>
<td>Idle(4)</td>
<td>从系统启动开始累积到当前时刻，除IO等待时间外的其他等待时间；</td>
</tr>
<tr>
<td>Iowait(5)</td>
<td>从系统启动开始累积到当前时刻，IO等待时间（since 2.5.41）;</td>
</tr>
<tr>
<td>Irq(6)</td>
<td>从系统启动开始累积到当前时刻，硬中断时间（since 2.6.0-tests4）；</td>
</tr>
<tr>
<td>Softirq(7)</td>
<td>从系统启动开始累积到当前时刻，软中断时间（since 2.6.0-test5）； </td>
</tr>
<tr>
<td>Steal(8)</td>
<td>Stolen time, which is the time spent in other operating systems when running in a virtualized environment(since 2.6.11);</td>
</tr>
<tr>
<td>Guest(9)</td>
<td>Time spent running a virtual CPU for guest operating systems under the control of the Linux kernel(since 2.6.24);</td>
</tr>
<tr>
<td>guest_nice(10)</td>
<td>Time spent running a niced guest (virtual CPU for guest operating systems under the control of the Linux kernel)( since 2.6.24);</td>
</tr>
</tbody>
</table>
<p>因为/proc/stat中的数值都是从系统启动开始累积到当前时刻的累加值，所以需要在不同时间点t1和t2取值进行比较运算，当两个时间点的间隔较短时，就可以把这个计算结果看做是CPU的即时利用率。<br>CPU即时利用率（时间间隔1s）计算公式如下：<br><em>CPU在t1到t2时间段总的使用时间 = ( user2+ nice2+ system2+ idle2+ iowait2+ irq2+ softirq2) –<br>( user1+ nice1+ system1+ idle1+ iowait1+ irq1+ softirq1)<br>CPU在t1到t2时间段空闲使用时间 = (idle2 - idle1)<br>CPU在t1到t2时间段即时利用率   =  1 - CPU空闲使用时间 / CPU总的使用时间</em></p>
<blockquote>
<p>注：在利用公式进行CPU即时利用率计算时，一定要先判断Total和idle，有时计算出来的idle比Total还要大，出现时间倒流现象，较早的发行版OS内核可能会出现。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;在Linux系统中，CPU时间的分配信息保存在/proc/stat文件中，我们就可以从这个文件中读取原始数据，然后计算出最终的CPU利用率的。&lt;/blockquote&gt;

&lt;p&gt;在Linux系统中，CPU时间的分配信息保存在/proc/stat文件中，我们就可以从这个文件中读取原始数据，然后计算出最终的CPU利用率的。这个文件的一般格式如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat /proc/stat
cpu  245501 20040 134027 122597803 39715 23822 74062 0
cpu0 96705 11277 84622 61249161 31399 23283 70496 0
cpu1 148795 8762 49405 61348642 8316 538 3566 0
intr 636408939 615480120 9 0 0 4 0 4 0 1 0 85 0 73 0 1844999 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 481644 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 16401031 0 0 0 0 0 0 0 2054028 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 146941 0 0 0 0 0 0 0 0 0 0 0 0 0
ctxt 30181583
btime 1488951210
processes 431551
procs_running 1
procs_blocked 0
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="技术总结" scheme="http://www.waverley.me/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
      <category term="手册速查" scheme="http://www.waverley.me/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/%E6%89%8B%E5%86%8C%E9%80%9F%E6%9F%A5/"/>
    
    
      <category term="Linux" scheme="http://www.waverley.me/tags/Linux/"/>
    
      <category term="proc" scheme="http://www.waverley.me/tags/proc/"/>
    
  </entry>
  
  <entry>
    <title>如何查看Linux中进程运行在哪个CPU上</title>
    <link href="http://www.waverley.me/2017/03/15/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8BLinux%E4%B8%AD%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%9C%A8%E5%93%AA%E4%B8%AACPU%E4%B8%8A/"/>
    <id>http://www.waverley.me/2017/03/15/如何查看Linux中进程运行在哪个CPU上/</id>
    <published>2017-03-15T12:43:00.000Z</published>
    <updated>2017-06-08T14:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>当Linux进程运行在多核系统中时，我们如何才能找出这个进程到底是运行在哪个CPU上？<br></blockquote>

<p>当你在一个多核NUMA处理器上运行一个高性能的应用程序或者高负载网络程序时，CPU/memory是一个限制它们性能的重要因素。在相同的NUMA节点调度处理器可以减少访问远程memory的性能降低。Intel的Sandy Bridge处理器，具有一个集成的PCIe控制器，你可以利用NIC card的PCI-to-CPU亲和性在同一个NUMA节点上调度网络I/O。</p>
<p>作为性能优化和问题定位的一部分，我们有时需要知道具体进程是运行在哪个CPU核心或者NUMA节点的。</p>
<p>下面介绍几种方法，可以帮助我们找到一个Linux进程是运行在哪个CPU核心上的。<br><a id="more"></a></p>
<h2 id="一、taskset"><a href="#一、taskset" class="headerlink" title="一、taskset"></a>一、taskset</h2><p>如果一个进程被绑定在特定的CPU，可以使用taskset命令找到这个被绑定的CPU：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ taskset -c -p &lt;pid&gt;</div></pre></td></tr></table></figure>
<p>例如，对于一个PID 5357的进程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ taskset -c -p 5357</div><div class="line">pid 5357&apos;s current affinity list: 5</div></pre></td></tr></table></figure></p>
<p>命令输出显示这个进程是被绑定到CPU核心5了。<br>然而，如果没有绑定任何CPU，将会看到如下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pid 5357&apos;s current affinity list: 0-11</div></pre></td></tr></table></figure></p>
<p>表明这个进程有可能被调度到0-11的任何CPU核心上，这种情况下，taskset将无法判断进程是被运行在哪个CPU上了，只能使用下面的方法。</p>
<h2 id="二、ps"><a href="#二、ps" class="headerlink" title="二、ps"></a>二、ps</h2><p>ps命令能够显示出每个进程/线程被分配的CPU ID(“PSR”列)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ps -o pid,psr,comm -p &lt;pid&gt;</div><div class="line">  PID  PSR COMMAND</div><div class="line">  5357  10 prog</div></pre></td></tr></table></figure></p>
<p>这个输出表明PID 5357进程（名字为prog）现在是运行在CPU核心10上。如果这个进程未被绑定CPU，则PSR列会根据被分配到的CPU随时间变化的。</p>
<h2 id="三、top"><a href="#三、top" class="headerlink" title="三、top"></a>三、top</h2><p>top命令也可以显示一个进程被分配的CPU。首先，运行top -p PID，然后按f键，并且增加“Last used CPU”列。现在正在使用的CPU核心将会显示在“P”（”PSR”）列下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ top -p 5357</div></pre></td></tr></table></figure></p>
<p><img src="http://waverley.me/assets/blogImg/linuxc1.jpg" alt="此处输入图片的描述"><br>相对ps命令，top命令的优势是你可以连续监视CPU如何随时间变化的。</p>
<h2 id="四、htop"><a href="#四、htop" class="headerlink" title="四、htop"></a>四、htop</h2><p>还有一个查看进程/现场正在使用的CPU的方法是htop命令。<br>运行htop命令，然后按<f2>键，选中”Columns”，在”Available Columns”下增加”PROCESSOR”。<br>如下图”CPU”列就是进程被调用的CPU ID。<br><img src="http://waverley.me/assets/blogImg/linuxc2.jpg" alt="此处输入图片的描述"></f2></p>
<p>注意：之前的命令taskset/ps/top被分配CPU核心IDs从0到N-1，然而htop是从1到N。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;当Linux进程运行在多核系统中时，我们如何才能找出这个进程到底是运行在哪个CPU上？&lt;br&gt;&lt;/blockquote&gt;

&lt;p&gt;当你在一个多核NUMA处理器上运行一个高性能的应用程序或者高负载网络程序时，CPU/memory是一个限制它们性能的重要因素。在相同的NUMA节点调度处理器可以减少访问远程memory的性能降低。Intel的Sandy Bridge处理器，具有一个集成的PCIe控制器，你可以利用NIC card的PCI-to-CPU亲和性在同一个NUMA节点上调度网络I/O。&lt;/p&gt;
&lt;p&gt;作为性能优化和问题定位的一部分，我们有时需要知道具体进程是运行在哪个CPU核心或者NUMA节点的。&lt;/p&gt;
&lt;p&gt;下面介绍几种方法，可以帮助我们找到一个Linux进程是运行在哪个CPU核心上的。&lt;br&gt;
    
    </summary>
    
      <category term="技术总结" scheme="http://www.waverley.me/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
      <category term="手册速查" scheme="http://www.waverley.me/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/%E6%89%8B%E5%86%8C%E9%80%9F%E6%9F%A5/"/>
    
    
      <category term="Linux" scheme="http://www.waverley.me/tags/Linux/"/>
    
      <category term="bash" scheme="http://www.waverley.me/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>如何在C程序中嵌入python代码</title>
    <link href="http://www.waverley.me/2017/03/04/%E5%A6%82%E4%BD%95%E5%9C%A8C%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%B5%8C%E5%85%A5python%E4%BB%A3%E7%A0%81/"/>
    <id>http://www.waverley.me/2017/03/04/如何在C程序中嵌入python代码/</id>
    <published>2017-03-04T14:59:00.000Z</published>
    <updated>2017-06-08T13:49:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">C语言与Python结合后，将会更加的强大。</blockquote>

<p>python是目前最流行的语言之一，它具有简明的语法，易于学习、跨平台支持等特点。此外，还有很多高质量的python库和模块，使你用很少的代码就可以实现复杂的功能。这使得python成为最有效的开发工具之一。然而，python不如C语言快速，很多高性能软件例如Linux操作系统，web server和数据库都是用C语言写的。如果你正在用C开发程序，但是一部分代码需要用python来写，你就可以写一个模块，使用Python/C API把这个模块嵌入到C程序中.<br><a id="more"></a></p>
<p>下面让我们一起来用Python/C API把python代码嵌入到C程序中。</p>
<ol>
<li>安装Python Development Package<br>首先要安装Python Development Package，如下：<br>Debian, Ubuntu or Linux Mint系统:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install python2.7-dev</div></pre></td></tr></table></figure>
</li>
</ol>
<p>CentOS, Fedora or RHEL系统:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install python-devel</div></pre></td></tr></table></figure></p>
<p>安装成功后，python头文件就在/usr/include/python2.7路径下，不同的Linux发行版，路径可能不同，例如CentOS6.x系统为/usr/include/python2.6。</p>
<ol>
<li>初始化解释器并设置路径<br>第一步是初始化python解释器，如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Py_Initialize();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>初始化成功后，需要设置你要导入到C程序中的python模块路径。例如，我们的python模块位于路径 /usr/local/modules，然后调入如下C函数设置路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PySys_SetPath(&quot;/usr/local/modules&quot;);</div></pre></td></tr></table></figure></p>
<ol>
<li>数据转换<br>将python嵌入到C中最重要的事情之一就是数据转换，为了把C数据传给python，我们需要将C数据类型转换为python数据类型。python/C API提供了一些函数，例如将C字符串转为python字符串，使用PyString_FromString()函数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PyObject *pval;</div><div class="line">char *cString = &quot;Cyberpersons&quot;;</div><div class="line">pval = PyString_FromString(cString);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>PyInt_FromLong()函数将C的long类型转换为python的int类型，每个Python/C API函数都返回一个相应的PyObject类型。</p>
<ol>
<li>定义一个python模块<br>当你想把python代码嵌入到另外一种语言时，需要写一个python模块，然后”import”到其他语言中。例如，我们写一个简单的python模块。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def printData(data):</div><div class="line">    return data+data+&apos;\n&apos;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的函数以字符串为参数，然后返回两个重复的字符串。这个模块的文件名称为”printData.py”然后把这个模块放入到之前声明的路径下（/usr/local/modules）。</p>
<ol>
<li><p>载入python模块<br>定了python模块，然后需要载入到C程序中。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// argv[1] specifies the module file name (&quot;printData.py&quot;).</div><div class="line">pName = PyString_FromString(argv[1]);</div><div class="line">pModule = PyImport_Import(pName);</div></pre></td></tr></table></figure>
</li>
<li><p>构建函数参数<br>载入模块后，就可以调用python模块中定义的函数了。一般我们需要传递一个或者多个参数到python函数中，我们就要构建一个包含python函数参数的python元组。<br>在我们的例子中，printData()函数需要一个参数，因此我们构建的python元组包含一个元素。可以用PyTuple_SetItem()函数来进行元组的设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">PyObject *pythonArgument;</div><div class="line">pythonArgument = PyTuple_New(1);</div><div class="line">pValue = PyString_FromString(argv[3]);</div><div class="line"> </div><div class="line">if(pValue==NULL)&#123;</div><div class="line">  return 1;</div><div class="line">&#125;</div><div class="line">PyTuple_SetItem(pythonArgument, 0, pValue);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这样我们就成功构建了一个可以传给函数的参数，然后就可以在C程序中调用python函数了。</p>
<ol>
<li><p>调用python函数<br>一旦python元组被成功创建，我们就可以用这个参数调用python函数。因此，首先用PyObject_GetAttrString()函数获取到python函数的引用，然后调用函数PyObject_CallObject()，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// argv[2] is the function name defined in pModule</div><div class="line">// pFunc is the reference to the function</div><div class="line">pFunc = PyObject_GetAttrString(pModule, argv[2]);</div><div class="line">pValue = PyObject_CallObject(pFunc, pythonArgument);</div></pre></td></tr></table></figure>
</li>
<li><p>Error检查<br>一个常用的消除运行时错误的方法是检查函数的返回值并且采取相应的动作。与C程序中一个error全局变量一样，当Python/C API函数失败，全局标识将会被设置到error，PyErr_Print()函数可以打印出可读调用栈，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pModule = PyImport_Import(pName);</div><div class="line">if (pModule != NULL) &#123;</div><div class="line">    // Do something useful here</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">   PyErr_Print();  // print traceback</div><div class="line">   fprintf(stderr, &quot;Failed to load \&quot;%s\&quot;\n&quot;, argv[1]);</div><div class="line">   return 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>你可以在程序中很容易进行error检查。<br>下面是一个完整的C程序，嵌入了python代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">// depending on distros, the exact path or Python version may vary.</div><div class="line">#include &lt;/usr/include/python2.7/Python.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    PyObject *pName, *pModule, *pDict, *pFunc;</div><div class="line">    PyObject *pArgs, *pValue;</div><div class="line"></div><div class="line">    Py_Initialize();</div><div class="line"></div><div class="line">    PySys_SetPath(&quot;/usr/local/modules&quot;);  // path to the module to import</div><div class="line">    pName = PyString_FromString(argv[1]);</div><div class="line"></div><div class="line">    pModule = PyImport_Import(pName);</div><div class="line">    if (pModule != NULL) &#123;</div><div class="line">        PyObject *pythonArgument;</div><div class="line">        pythonArgument = PyTuple_New(1);</div><div class="line">        pValue = PyString_FromString(argv[3]);</div><div class="line"></div><div class="line">        if (pValue == NULL) &#123;</div><div class="line">            return 1;</div><div class="line">        &#125;</div><div class="line">        PyTuple_SetItem(pythonArgument, 0, pValue);</div><div class="line">        pFunc = PyObject_GetAttrString(pModule, argv[2]);</div><div class="line">        if (pFunc &amp;&amp; PyCallable_Check(pFunc)) &#123;</div><div class="line">            pValue = PyObject_CallObject(pFunc, pythonArgument);</div><div class="line">            if (pValue != NULL) &#123;</div><div class="line">                printf(&quot;Value returuend from the function %s&quot;, PyString_AsString(pValue));</div><div class="line">            &#125; else &#123;</div><div class="line">                PyErr_Print();</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (PyErr_Occurred())</div><div class="line">                PyErr_Print();</div><div class="line">            fprintf(stderr, &quot;Cannot find function \&quot;%s\&quot;\n&quot;, argv[2]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        PyErr_Print();</div><div class="line">        fprintf(stderr, &quot;Failed to load \&quot;%s\&quot;\n&quot;, argv[1]);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>编译并运行<br>将上面代码保存为finalCode.c，然后编译代码，用python库(-lpython2.7)连接。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gcc -o final finalCode.c -lpython2.7</div></pre></td></tr></table></figure>
</li>
</ol>
<p>然后用三个参数执行编译后的程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./final printData printData cyberpersons</div></pre></td></tr></table></figure></p>
<p>这三个参数分别是模块名称、模块中的函数名称、传给python函数的字符串参数。<br>最终，输出如下所示：<br><img src="http://waverley.me/assets/blogImg/pyhton-c.jpg" alt="此处输入图片的描述"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;C语言与Python结合后，将会更加的强大。&lt;/blockquote&gt;

&lt;p&gt;python是目前最流行的语言之一，它具有简明的语法，易于学习、跨平台支持等特点。此外，还有很多高质量的python库和模块，使你用很少的代码就可以实现复杂的功能。这使得python成为最有效的开发工具之一。然而，python不如C语言快速，很多高性能软件例如Linux操作系统，web server和数据库都是用C语言写的。如果你正在用C开发程序，但是一部分代码需要用python来写，你就可以写一个模块，使用Python/C API把这个模块嵌入到C程序中.&lt;br&gt;
    
    </summary>
    
      <category term="技术总结" scheme="http://www.waverley.me/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://www.waverley.me/tags/python/"/>
    
      <category term="c语言" scheme="http://www.waverley.me/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>GIT:修改远端的提交</title>
    <link href="http://www.waverley.me/2017/01/30/GIT-%E4%BF%AE%E6%94%B9%E8%BF%9C%E7%AB%AF%E7%9A%84%E6%8F%90%E4%BA%A4/"/>
    <id>http://www.waverley.me/2017/01/30/GIT-修改远端的提交/</id>
    <published>2017-01-30T13:40:00.000Z</published>
    <updated>2017-06-08T13:51:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">当你不小心，写错了提交的commit/message，该如何处理呢？<br>强大的GIT早已经为你备好了“后悔药”。</blockquote>



<h2 id="1、修改最后一次提交"><a href="#1、修改最后一次提交" class="headerlink" title="1、修改最后一次提交"></a>1、修改最后一次提交</h2><p>理论上，SCM是不应该修改历史记录的，提交的注释也，不过在git中，其commit提供了一个–amend参数，可以修改最后一次提交的信息。要对最后一次提交进行修改，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add xxx</div><div class="line">git commit --ammend</div></pre></td></tr></table></figure></p>
<p>这时出现的对话框中，可以进行message的编辑，然后退出，完成对本地最后一次提交的修改，然后再提交到远端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin remote_branch -f</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="2、修改历史提交"><a href="#2、修改历史提交" class="headerlink" title="2、修改历史提交"></a>2、修改历史提交</h2><p>git使用amend选项提供了最后一次commit的反悔。但是对于历史提交呢，就必须使用rebase了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rebase -i HEAD~3</div></pre></td></tr></table></figure></p>
<p>表示要修改当前版本的倒数第三次状态。<br>这个命令出来之后，会显示出类似如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pick:******* </div><div class="line">pick:******* </div><div class="line">pick:*******</div></pre></td></tr></table></figure></p>
<p> 如果你要修改哪个，就把那行的<strong>pick改成edit</strong>，然后退出。<br> 这时通过git log你可以发现，git的最后一次提交已经变成你选的那个了，这时再使用步骤1进行最后一次本地修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit --amend</div></pre></td></tr></table></figure></p>
<p> 修改完了之后，要恢复之后的commit记录,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git rebase --continue </div><div class="line">``` </div><div class="line">这时通过git log你可以看到已经恢复了之前的历史记录。</div><div class="line">最后再提交本地到远端:</div></pre></td></tr></table></figure></p>
<p>git push origin remote_branch -f<br>```</p>
<blockquote>
<p>注：GIT可以修改远端的历史提交，但是所修改commit及之后的所有的提交时间均被修改为修改时间了。<br>另：如果这个过程中有操作错误，可以使用 git rebase –abort来撤销修改，回到没有开始操作合并之前的状态。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;当你不小心，写错了提交的commit/message，该如何处理呢？&lt;br&gt;强大的GIT早已经为你备好了“后悔药”。&lt;/blockquote&gt;



&lt;h2 id=&quot;1、修改最后一次提交&quot;&gt;&lt;a href=&quot;#1、修改最后一次提交&quot; class=&quot;headerlink&quot; title=&quot;1、修改最后一次提交&quot;&gt;&lt;/a&gt;1、修改最后一次提交&lt;/h2&gt;&lt;p&gt;理论上，SCM是不应该修改历史记录的，提交的注释也，不过在git中，其commit提供了一个–amend参数，可以修改最后一次提交的信息。要对最后一次提交进行修改，如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git add xxx&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git commit --ammend&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这时出现的对话框中，可以进行message的编辑，然后退出，完成对本地最后一次提交的修改，然后再提交到远端：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git push origin remote_branch -f&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术总结" scheme="http://www.waverley.me/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
      <category term="手册速查" scheme="http://www.waverley.me/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/%E6%89%8B%E5%86%8C%E9%80%9F%E6%9F%A5/"/>
    
    
      <category term="Git" scheme="http://www.waverley.me/tags/Git/"/>
    
      <category term="手册" scheme="http://www.waverley.me/tags/%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>GIT:重新组织本地提交</title>
    <link href="http://www.waverley.me/2017/01/16/GIT-%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E6%9C%AC%E5%9C%B0%E6%8F%90%E4%BA%A4/"/>
    <id>http://www.waverley.me/2017/01/16/GIT-重新组织本地提交/</id>
    <published>2017-01-16T06:40:00.000Z</published>
    <updated>2017-06-08T13:36:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">git可以让你对本地commit进行顺序调整，优化commit的组织性，然后再进行提交。</blockquote>

<p>以git为首的SVCS现在已经很流行了，目前越来的企业和开源组织都在使用或者迁移到git上，github让git更加出色和流行。每次提到git，都会和SVN进行对比，当然这其中可以对比的因素。我这次主要就可以git可以本地提交的特性讲述如何在push之前对本地的commit进行重组。</p>
<h2 id="本地commit重组的必要性"><a href="#本地commit重组的必要性" class="headerlink" title="本地commit重组的必要性"></a>本地commit重组的必要性</h2><p>在开发过程中，有很多优秀的实践指导着我们，其中有一条是“每次提交一个功能点”，意思是说每次提交应该是一个独立的单元，还有另外一条优秀实践是“频繁提交，小提交”，意思是说要频繁提交代码，并且最好是小的提交。其实这两条都没错，但是总是感觉有点冲突和矛盾。如果想完美做到第一条，那么写代码之前要好好规划，每次提交要修改哪些文件，然后才能一次提交一个完整的单元，但是这么做又会产生大commit，和第二条有冲突。考虑到很难在开发之前，设计那么清楚，就像设计大功能一样，可以边做边重构，甚至是做完重构。</p>
<p>所以针对git本地的commit也是一样，可以先比较频繁地执行小提交，这样每个小提交可以达到一个提交一个功能了。这样本地会产生很多commit，这些commit比较散乱，逻辑关联性也不强，甚至有些commit是本地测试用的，有的commit需要拆成两个，有个多个commit可以合并，commit之间顺序需要调换等等，经过这些过程，本地commit可以调整得很有序，而且组织性特别好。<br><a id="more"></a></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>需要开发三个功能function-1、function-2以及function-3，由于自己没有想清楚，开发有点散乱，提交之后的git log如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">8e68ded function-3-all-big</div><div class="line">aad65ef function-2[2/2]</div><div class="line">721d5e9 function-1[2/2]</div><div class="line">8ac73c9 function-2[1/2]</div><div class="line">f1927eb modified properties to local test</div><div class="line">b29c96f function-1[1/2]</div></pre></td></tr></table></figure></p>
<p>从log可以看到，function-1被分在了两个commit提交，而且中间夹杂着一个为了测试修改配置的commit（这个commit不应该push到代码库），仔细去看，function-1和function-2穿插着提交了。而function-3是一个比较大的提交，提交之后我觉得可以function-3完全可以拆成两个子功能分开提交。</p>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>一、先把function-1和function-2的穿插问题解决掉，就是调换function-2[1/2]和function-1[2/2]顺序，因为是两个功能，所以代码不会很大的冲突。<br>执行git rebase -i进入交互模式，自动打开vim，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pick b29c96f function-1[1/2]</div><div class="line">pick f1927eb modified properties to local test</div><div class="line">pick 8ac73c9 function-2[1/2]</div><div class="line">pick 721d5e9 function-1[2/2]</div><div class="line">pick aad65ef function-2[2/2]</div><div class="line">pick ac10187 function-3-all-big</div></pre></td></tr></table></figure></p>
<p>从这个看上去和git log的输出很相似，只是顺序恰好是倒置的，最先提交的commit在最上边。现在调换function-2[1/2]和function-1[2/2]顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pick b29c96f function-1[1/2]</div><div class="line">pick f1927eb modified properties to local test</div><div class="line">pick 721d5e9 function-1[2/2]</div><div class="line">pick 8ac73c9 function-2[1/2]</div><div class="line">pick aad65ef function-2[2/2]</div><div class="line">pick ac10187 function-3-all-big</div></pre></td></tr></table></figure></p>
<p>保存，退出编辑器，git会自动执行rebase操作，之后执行git log观察下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">b761ac1 function-3-all-big</div><div class="line">4152266 function-2[2/2]</div><div class="line">9c09ceb function-2[1/2]</div><div class="line">c9fed87 function-1[2/2]</div><div class="line">f1927eb modified properties to local test</div><div class="line">b29c96f function-1[1/2]</div></pre></td></tr></table></figure></p>
<p>发现function-2[1/2]和function-1[2/2]顺序已经调换了。</p>
<p>二、删除modified properties to local test这个commit，使得本地测试代码不会push到远程代码库。这个比较容易，执行git rebase -i，在编辑器中直接删除pick f1927eb modified properties to local test这一行，保存并退出编辑器，执行rebase操作。此后可以执行git log看下输出内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">998a582 function-3-all-big</div><div class="line">b67b728 function-2[2/2]</div><div class="line">ff9f827 function-2[1/2]</div><div class="line">1a7ebaa function-1[2/2]</div><div class="line">b29c96f function-1[1/2]</div></pre></td></tr></table></figure></p>
<p>不需要push的那个提交已经被踢出了。</p>
<p>三、把需要合并的提交合并掉使其变成一个更内聚的提交。首先合并function-1[1/2]和function-1[2/2]，执行git rebase -i，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pick b29c96f function-1[1/2]</div><div class="line">pick 1a7ebaa function-1[2/2]</div><div class="line">pick ff9f827 function-2[1/2]</div><div class="line">pick b67b728 function-2[2/2]</div><div class="line">pick 998a582 function-3-all-big</div></pre></td></tr></table></figure></p>
<p>这个只需要把第二行的pick改成s，保存退出编辑器，这个时候会在编辑器中重新编辑前面两个commit的comment，于是修改正function-1即可。看下git log输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ac884c8 function-3-all-big</div><div class="line">b992119 function-2[2/2]</div><div class="line">9549400 function-2[1/2]</div><div class="line">150ff1a function-1</div></pre></td></tr></table></figure></p>
<p>这样看来function-1的两部分被合并了，变成一个单一的commit了。同样的方式来处理function2的两个commit。最后的git log输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">236128f function-3-all-big</div><div class="line">1188917 function-2</div><div class="line">150ff1a function-1</div></pre></td></tr></table></figure></p>
<p>function-1和function-2都合并了。</p>
<p>四、拆分function-3为function-3-module-1和function-3-module-2两个独立commit。先执行git reset –soft HEAD^，这样先回退一个commit，变成function-3提交前的状态，这样可以commit的内容还在，只是出于未提交状态。这样就可以自由选择把未提交的内容分成几次提交了，我们做成两个commit。现在git log看下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">3a27021 function-3-module-2</div><div class="line">7829bd8 function-3-module-1</div><div class="line">1188917 function-2</div><div class="line">150ff1a function-1</div></pre></td></tr></table></figure></p>
<p>五、结果已经完美了，执行git push，当然先执行git pull –rebase可能是个更好的习惯。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因为git有local commit，既可以“随意”提交小提交，又可以在push之前修整成很漂亮的功能单元，一个commit一个单元，从而让我们有“后悔药”，也是为了做出更好的代码质量。不过一定要注意，rebase应该只操作还未push到远程仓库的commit，一旦push到了远程仓库，那么不允许再修改commit，不然会给其他开发带来很多麻烦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;git可以让你对本地commit进行顺序调整，优化commit的组织性，然后再进行提交。&lt;/blockquote&gt;

&lt;p&gt;以git为首的SVCS现在已经很流行了，目前越来的企业和开源组织都在使用或者迁移到git上，github让git更加出色和流行。每次提到git，都会和SVN进行对比，当然这其中可以对比的因素。我这次主要就可以git可以本地提交的特性讲述如何在push之前对本地的commit进行重组。&lt;/p&gt;
&lt;h2 id=&quot;本地commit重组的必要性&quot;&gt;&lt;a href=&quot;#本地commit重组的必要性&quot; class=&quot;headerlink&quot; title=&quot;本地commit重组的必要性&quot;&gt;&lt;/a&gt;本地commit重组的必要性&lt;/h2&gt;&lt;p&gt;在开发过程中，有很多优秀的实践指导着我们，其中有一条是“每次提交一个功能点”，意思是说每次提交应该是一个独立的单元，还有另外一条优秀实践是“频繁提交，小提交”，意思是说要频繁提交代码，并且最好是小的提交。其实这两条都没错，但是总是感觉有点冲突和矛盾。如果想完美做到第一条，那么写代码之前要好好规划，每次提交要修改哪些文件，然后才能一次提交一个完整的单元，但是这么做又会产生大commit，和第二条有冲突。考虑到很难在开发之前，设计那么清楚，就像设计大功能一样，可以边做边重构，甚至是做完重构。&lt;/p&gt;
&lt;p&gt;所以针对git本地的commit也是一样，可以先比较频繁地执行小提交，这样每个小提交可以达到一个提交一个功能了。这样本地会产生很多commit，这些commit比较散乱，逻辑关联性也不强，甚至有些commit是本地测试用的，有的commit需要拆成两个，有个多个commit可以合并，commit之间顺序需要调换等等，经过这些过程，本地commit可以调整得很有序，而且组织性特别好。&lt;br&gt;
    
    </summary>
    
      <category term="技术总结" scheme="http://www.waverley.me/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
      <category term="手册速查" scheme="http://www.waverley.me/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/%E6%89%8B%E5%86%8C%E9%80%9F%E6%9F%A5/"/>
    
    
      <category term="Git" scheme="http://www.waverley.me/tags/Git/"/>
    
      <category term="手册" scheme="http://www.waverley.me/tags/%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>python高并发爬取网络数据</title>
    <link href="http://www.waverley.me/2016/12/02/python%E9%AB%98%E5%B9%B6%E5%8F%91%E7%88%AC%E5%8F%96%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE/"/>
    <id>http://www.waverley.me/2016/12/02/python高并发爬取网络数据/</id>
    <published>2016-12-02T15:30:00.000Z</published>
    <updated>2016-12-21T15:48:29.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">对比测试协程（asyncio）和异步IO（aiohttp）在爬虫中的优秀表现。</blockquote>

<p><img src="http://waverley.me/assets/blogImg/aio0.png" alt="此处输入图片的描述"></p>
<a id="more"></a>
<p>Python中解决IO密集型任务（打开多个网站）的方式有很多种，比如多进程、多线程。但理论上一台电脑中的线程数、进程数是有限的，而且进程、线程之间的切换也比较浪费时间。所以就出现了“协程”的概念。本文将利用协程（<a href="https://docs.python.org/3/library/asyncio.html" target="_blank" rel="external">asyncio</a>）和异步IO（<a href="https://aiohttp.readthedocs.io/en/latest/client.html" target="_blank" rel="external">aiohttp</a>）快速爬取网络数据，并对三种获取方式进行对比。</p>
<h2 id="一、Requests方式"><a href="#一、Requests方式" class="headerlink" title="一、Requests方式"></a>一、<a href="http://www.python-requests.org/en/master/" target="_blank" rel="external">Requests</a>方式</h2><p><a href="http://www.python-requests.org/en/master/" target="_blank" rel="external">Requests</a> 是用Python语言编写，基于 urllib，采用 Apache2 Licensed 开源协议的 HTTP 库。它比 urllib 更加方便，可以节约我们大量的工作。<br>下面我们使用<a href="http://www.python-requests.org/en/master/" target="_blank" rel="external">Requests</a>来获取雪球网站3000只股票信息（这里我用使用uid和token来登录网站网站）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"># coding:utf-8</div><div class="line">import requests</div><div class="line">import json</div><div class="line">import time</div><div class="line">headers = &#123;</div><div class="line">    &apos;Cookie&apos;: &apos;xq_a_token=XXX;u=XXX&apos;,</div><div class="line">    &apos;User-Agent&apos;: &apos;Xueqiu Android 8.9&apos;,</div><div class="line">    &apos;Host&apos;: &apos;stock.xueqiu.com&apos;,</div><div class="line">    &apos;Pragma&apos;: &apos;no-cache&apos;,</div><div class="line">    &apos;Connection&apos;: &apos;keep-alive&apos;,</div><div class="line">    &apos;Accept-Encoding&apos;: &apos;gzip&apos;,</div><div class="line">    &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.8&apos;</div><div class="line">&#125;</div><div class="line">session = requests.Session()</div><div class="line">session.headers.update(headers)</div><div class="line">url = &apos;https://xueqiu.com/stock/forchartk/stocklist.json?symbol=SH601211&amp;period=60m&amp;type=normal&amp;begin=1480986000000&amp;end=&amp;_=1479483981359&apos;</div><div class="line">while True:</div><div class="line">    start_time = time.time()</div><div class="line">    for _ in range(300):#重复300次</div><div class="line">        request = session.get(url)</div><div class="line">        stocks = json.loads(request.text)</div><div class="line">    end_time = time.time()</div><div class="line">    print(&quot;%s second&quot; % (end_time - start_time))</div></pre></td></tr></table></figure></p>
<p><img src="http://waverley.me/assets/blogImg/aio2.png" alt="此处输入图片的描述"><br>从运行结果可以看到获取300只股票大概需要12s，那么3000只大概是120s；我们同时也可以看到程序的网络带宽利用率最大值仅仅为650kBit/s;<br><img src="http://waverley.me/assets/blogImg/aio1.png" alt="此处输入图片的描述"></p>
<h2 id="二、threadpool和requests"><a href="#二、threadpool和requests" class="headerlink" title="二、threadpool和requests"></a>二、threadpool和requests</h2><p>这次我们使用threadpool来增加并发能力，提升获取的速率；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"># coding:utf-8</div><div class="line">import time</div><div class="line">import json</div><div class="line">import requests</div><div class="line">import threadpool</div><div class="line">headers = &#123;</div><div class="line">    &apos;Cookie&apos;: &apos;xq_a_token=xxx;u=xxx&apos;,</div><div class="line">    &apos;User-Agent&apos;: &apos;Xueqiu Android 8.8&apos;,</div><div class="line">    &apos;Host&apos;: &apos;stock.xueqiu.com&apos;,</div><div class="line">    &apos;Pragma&apos;: &apos;no-cache&apos;,</div><div class="line">    &apos;Connection&apos;: &apos;keep-alive&apos;,</div><div class="line">    &apos;Accept-Encoding&apos;: &apos;gzip&apos;,</div><div class="line">    &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.8&apos;</div><div class="line">&#125;</div><div class="line">url = &apos;https://xueqiu.com/stock/forchartk/stocklist.json?symbol=SH601211&amp;period=60m&amp;type=normal&amp;begin=1480986000000&amp;end=&amp;_=1479483981359&apos;</div><div class="line">session = requests.Session()</div><div class="line">session.headers.update(headers)</div><div class="line">def get_stocks(url_list):</div><div class="line">    request = session.get(url_list)</div><div class="line">    stocks = json.loads(request.text)</div><div class="line">    return stocks</div><div class="line"></div><div class="line">#模拟3000只股票</div><div class="line">url_list = [url for x in range(3000)]</div><div class="line"></div><div class="line">pool = threadpool.ThreadPool(70)</div><div class="line">while True:</div><div class="line">    start_time = time.time()</div><div class="line">    requests = threadpool.makeRequests(get_stocks, url_list)</div><div class="line">    [pool.putRequest(req) for req in requests]</div><div class="line">    pool.wait()</div><div class="line">    end_time = time.time()</div><div class="line">    print(&quot;%s second&quot; % (end_time - start_time))</div></pre></td></tr></table></figure></p>
<p><img src="http://waverley.me/assets/blogImg/aio4.png" alt="此处输入图片的描述"></p>
<p>这次我们从运行结果可以看到，使用线程池后，获取3000只股票信息只需要25s了；并且这里的70个线程已经是最佳效果了；此时，我们可以看到程序的网络带宽利用率最大值已经达到了4.54MBit/s。<br><img src="http://waverley.me/assets/blogImg/aio3.png" alt="此处输入图片的描述"></p>
<h2 id="三、asyncio和aiohttp高并发"><a href="#三、asyncio和aiohttp高并发" class="headerlink" title="三、asyncio和aiohttp高并发"></a>三、asyncio和aiohttp高并发</h2><p>现在，我们来一起测试下asyncio和aiohttp的高并发能力：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"># coding:utf-8</div><div class="line">import time</div><div class="line">import asyncio</div><div class="line">import json</div><div class="line">import aiohttp</div><div class="line">import yarl</div><div class="line"></div><div class="line">class TestAIOhttp:</div><div class="line"></div><div class="line">    def __init__(self):</div><div class="line">        self.headers = &#123;</div><div class="line">            &apos;Cookie&apos;: &apos;xq_a_token=xxx;u=xxx&apos;,</div><div class="line">            &apos;User-Agent&apos;: &apos;Xueqiu Android 8.8&apos;,</div><div class="line">            &apos;Host&apos;: &apos;stock.xueqiu.com&apos;,</div><div class="line">            &apos;Pragma&apos;: &apos;no-cache&apos;,</div><div class="line">            &apos;Connection&apos;: &apos;keep-alive&apos;,</div><div class="line">            &apos;Accept-Encoding&apos;: &apos;gzip&apos;,</div><div class="line">            &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.8&apos;</div><div class="line">        &#125;</div><div class="line">        self.url = &apos;https://xueqiu.com/stock/forchartk/stocklist.json?period=60m&amp;type=normal&amp;begin=1480986000000&amp;end=&amp;_=1479483981359&amp;symbol=&apos;</div><div class="line">        #模拟3000只股票</div><div class="line">        self.stock_list = [&apos;SH601211&apos; for x in range(3000)]</div><div class="line"></div><div class="line">    @property</div><div class="line">    def all(self):</div><div class="line">        return self.get_stock(self.stock_list)</div><div class="line"></div><div class="line">    async def get_stocks_by_range(self, params):</div><div class="line">        url = yarl.URL(self.url + params, encoded=True)</div><div class="line">        try:</div><div class="line">            async with self.__session.get(url, timeout=10, headers=self.headers) as r:</div><div class="line">                response_text = await r.text()</div><div class="line">                return response_text</div><div class="line">        except asyncio.TimeoutError:</div><div class="line">            return None</div><div class="line"></div><div class="line">    def get_stock(self, stock_list):</div><div class="line">        self.__session = aiohttp.ClientSession()</div><div class="line">        coroutines = []</div><div class="line">        result_str = &apos;&apos;</div><div class="line"></div><div class="line">        for params in stock_list:</div><div class="line">            coroutine = self.get_stocks_by_range(params)</div><div class="line">            coroutines.append(coroutine)</div><div class="line">        try:</div><div class="line">            loop = asyncio.get_event_loop()</div><div class="line">        except RuntimeError:</div><div class="line">            loop = asyncio.new_event_loop()</div><div class="line">            asyncio.set_event_loop(loop)</div><div class="line">        res = loop.run_until_complete(asyncio.gather(*coroutines))</div><div class="line"></div><div class="line">        self.__session.close()</div><div class="line">        return &apos;[&apos; + &apos;,&apos;.join([x for x in res if x is not None and len(x) &gt; 2]) + &apos;]&apos;</div><div class="line">    </div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    q = TestAIOhttp()</div><div class="line">    while True:</div><div class="line">        start_time = time.time()</div><div class="line">        data = q.all</div><div class="line">        end_time = time.time()</div><div class="line">        print(&quot;%s second&quot; % (end_time - start_time))</div></pre></td></tr></table></figure></p>
<p><img src="http://waverley.me/assets/blogImg/aio6.png" alt="此处输入图片的描述"><br>这次我们获取3000只股票信息只需要10s了，同时程序的网络带宽利用率最大值也达到了将近10MBit/s，这也是我20M带宽wifi的极限了；此处的测试瓶颈已经是我的网络带宽了，若提供更多的带宽资源，得到的数据可能会更加完美；不过，这里的三种方法的对比结果已经很明显了，在需要迅速爬取大量网络数据时，asyncio和aiohttp不失是一种不错的选择。<br><img src="http://waverley.me/assets/blogImg/aio5.png" alt="此处输入图片的描述"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;对比测试协程（asyncio）和异步IO（aiohttp）在爬虫中的优秀表现。&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://waverley.me/assets/blogImg/aio0.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术总结" scheme="http://www.waverley.me/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Jupyter Notebook" scheme="http://www.waverley.me/tags/Jupyter-Notebook/"/>
    
      <category term="工具" scheme="http://www.waverley.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Python" scheme="http://www.waverley.me/tags/Python/"/>
    
      <category term="爬虫" scheme="http://www.waverley.me/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="高并发" scheme="http://www.waverley.me/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Gmaps:轻松集成Google Maps</title>
    <link href="http://www.waverley.me/2016/10/21/Gmaps-%E8%BD%BB%E6%9D%BE%E9%9B%86%E6%88%90Google%20Maps%E7%9A%84Jupyter%20Notebook%E6%8F%92%E4%BB%B6/"/>
    <id>http://www.waverley.me/2016/10/21/Gmaps-轻松集成Google Maps的Jupyter Notebook插件/</id>
    <published>2016-10-20T16:30:00.000Z</published>
    <updated>2016-12-21T15:50:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">Gmaps是一个嵌入了Google Mpas的jupyter插件，是一个强大的数据可视化工具.</blockquote>


<p>Gmaps可以让你很简单地调用Google Maps，本文将简单介绍Gmaps的入门知识,以及有关热力图的绘制。<br><a id="more"></a></p>
<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><ol>
<li><p>最新版本的Gmaps需要升级你的IPython到4.2及以上版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install -U jupyter</div></pre></td></tr></table></figure>
</li>
<li><p>用pip命令进行模块安装，并使jupyter加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pip install gmaps</div><div class="line">jupyter nbextension enable --py gmaps</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="二、申请API-Key"><a href="#二、申请API-Key" class="headerlink" title="二、申请API Key"></a>二、申请API Key</h2><ol>
<li><p>要通过Google Maps的认证，你首先需要申请一个API Key，<a href="https://console.developers.google.com/projectselector/apis/api/static_maps_backend/overview" target="_blank" rel="external">申请连接</a>。进入申请界面，创建工程，然后点击<em>凭证</em>，选择<em>API密钥</em>，如下图<img src="http://waverley.me/assets/blogImg/gmaps1.png" alt="此处输入图片的描述"></p>
</li>
<li><p>获取API Key之后，通过如下函数来进行配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gmaps.configure(api_key=&quot;AI...&quot;)</div></pre></td></tr></table></figure>
<p>或者，通过环境变量来进行设置（文件 ~/.profile 或 ~/.bashrc）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export GOOGLE_API_KEY=AI...</div></pre></td></tr></table></figure>
<p>然后，在jupyter中通过如下方式使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line">import gmaps</div><div class="line">gmaps.configure(api_key=os.environ[&quot;GOOGLE_API_KEY&quot;])</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这样，Maps和图层就可以通过你的API key来进行认证；</p>
<h2 id="三、开始使用"><a href="#三、开始使用" class="headerlink" title="三、开始使用"></a>三、开始使用</h2><p>Gmaps是一个嵌入了Google Mpas的jupyter插件，是一个数据可视化工具。<br>首先，让我们来画一个地震分布图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import gmaps</div><div class="line">import gmaps.datasets</div><div class="line"></div><div class="line">gmaps.configure(api_key=&quot;AI...&quot;) # Fill in with your API key</div><div class="line"></div><div class="line">earthquake_data = gmaps.datasets.load_dataset(&quot;earthquakes&quot;)</div><div class="line"></div><div class="line">print(earthquake_data[:4]) # first four rows</div><div class="line"></div><div class="line">#在Google Mpas上画出地震分布图</div><div class="line">m = gmaps.Map()</div><div class="line">m.add_layer(gmaps.WeightedHeatmap(data=earthquake_data))</div><div class="line">m</div></pre></td></tr></table></figure></p>
<p><img src="http://waverley.me/assets/blogImg/gmaps2.png" alt="此处输入图片的描述"><br>这是一个完整的Google Maps，你可以放大缩小、卫星视图、街景等，并且热力图将会自适应。</p>
<h2 id="四、基本原理"><a href="#四、基本原理" class="headerlink" title="四、基本原理"></a>四、基本原理</h2><p>gmaps是在原生Google Maps上添加一个图层；当你创建一个基本地图后，然后你可以在地图上增加一个新的图层，例如热力图层：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import gmaps</div><div class="line">gmaps.configure(api_key=&quot;AI...&quot;)</div><div class="line"></div><div class="line">m = gmaps.Map()</div><div class="line"></div><div class="line"># 初始化一些数据</div><div class="line">data = [(51.5, 0.1), (51.7, 0.2), (51.4, -0.2), (51.49, 0.1)]</div><div class="line"></div><div class="line">heatmap_layer = gmaps.Heatmap(data=data)</div><div class="line">m.add_layer(heatmap_layer)</div><div class="line">m</div></pre></td></tr></table></figure></p>
<p><img src="http://waverley.me/assets/blogImg/gmaps3.png" alt="此处输入图片的描述"><br>你还可以通过一些参数来调整图层，如下两种方式是等价的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">heatmap_layer = gmaps.Heatmap(data=data)</div><div class="line">heatmap_layer.point_radius = 8</div></pre></td></tr></table></figure></p>
<p>和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">heatmap_layer = gmaps.Heatmap(data=data, point_radius=8)</div></pre></td></tr></table></figure></p>
<p>第一种可在图层已经建立之后，通过调整参数来动态调整图层；</p>
<h2 id="五、热力图"><a href="#五、热力图" class="headerlink" title="五、热力图"></a>五、热力图</h2><p>热力图是一种很好的描述特定地理位置的某一事件集中程度的方法，是一个可以展示大量数据信息的强大工具。例如，我们将1997年到2015年之间发生在非洲的110,000 起暴力事件展示出来;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import gmaps</div><div class="line">import gmaps.datasets</div><div class="line">gmaps.configure(&quot;AI...&quot;)</div><div class="line"></div><div class="line">m = gmaps.Map()</div><div class="line"></div><div class="line">data = gmaps.datasets.load_dataset(&quot;acled_africa.csv&quot;)</div><div class="line">heatmap_layer = gmaps.Heatmap(data=data)</div><div class="line">m.add_layer(heatmap_layer)</div><div class="line">m</div></pre></td></tr></table></figure></p>
<p><img src="http://waverley.me/assets/blogImg/gmaps4.png" alt="此处输入图片的描述"></p>
<ul>
<li>缩放热散<br>当你在放大或缩小地图时，热力点可能会消失，这时你可以用<em>max_intensity</em>（最大峰值强度）参数来进行设置，当你的数据有明显的峰值时，这个参数是非常有用的；这个值通常配合<em>point_radius</em>（点半径）参数一起来进行调整，直到调整到你以为合适的数值：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">heatmap_layer.max_intensity = 100</div><div class="line">heatmap_layer.point_radius = 5</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Google maps还提供了一个dissipating参数（默认为true），当为true时，每个点的影响半径与缩放级别相关；当为false时，每个点覆盖的物理半径保持不变；</p>
<ul>
<li>设置颜色梯度和不透明度<br>Gmaps可以通过一个颜色列表来进行颜色梯度的设置，并且Google maps将会自动在相邻颜色间进行插值，颜色设置可以<a href="https://www.w3.org/TR/css3-color/#html4" target="_blank" rel="external">这样</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">heatmap.gradient = [</div><div class="line">    &apos;white&apos;,</div><div class="line">    &apos;silver&apos;,</div><div class="line">    &apos;gray&apos;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>或者RGB/RGBA元组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">heatmap.gradient = [</div><div class="line">    (200, 200, 200, 0.6),</div><div class="line">    (100, 100, 100, 0.3),</div><div class="line">    (50, 50, 50, 0.3)</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p><img src="http://waverley.me/assets/blogImg/gmaps5.png" alt="此处输入图片的描述"><br>还可以通过<em>opacity</em>参数来调整热力图层的不透明度。</p>
<ul>
<li>权重热力图<br>权重热力图与热力图一样，仅仅是多了数据元组中多了权重项(latitude, longitude, weight)；由于Google Maps的限制，权重项必须是正值；<br><img src="http://waverley.me/assets/blogImg/gmaps6.png" alt="此处输入图片的描述"></li>
</ul>
<h2 id="六、其他功能"><a href="#六、其他功能" class="headerlink" title="六、其他功能"></a>六、其他功能</h2><p>  Gmaps插件的功能远不止这些，以上仅仅介绍了有关热力图部分，更多功能等待大家一同去学习。项目源码见我的<a href="https://github.com/newctech/gmaps" target="_blank" rel="external">github</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;Gmaps是一个嵌入了Google Mpas的jupyter插件，是一个强大的数据可视化工具.&lt;/blockquote&gt;


&lt;p&gt;Gmaps可以让你很简单地调用Google Maps，本文将简单介绍Gmaps的入门知识,以及有关热力图的绘制。&lt;br&gt;
    
    </summary>
    
      <category term="技术总结" scheme="http://www.waverley.me/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
      <category term="手册速查" scheme="http://www.waverley.me/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/%E6%89%8B%E5%86%8C%E9%80%9F%E6%9F%A5/"/>
    
    
      <category term="Jupyter Notebook" scheme="http://www.waverley.me/tags/Jupyter-Notebook/"/>
    
      <category term="工具" scheme="http://www.waverley.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Gmaps" scheme="http://www.waverley.me/tags/Gmaps/"/>
    
      <category term="热力图heatmap" scheme="http://www.waverley.me/tags/%E7%83%AD%E5%8A%9B%E5%9B%BEheatmap/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter Notebook：交互计算工具</title>
    <link href="http://www.waverley.me/2016/09/04/Jupyter%20Notebook%EF%BC%9A%E4%BA%A4%E4%BA%92%E8%AE%A1%E7%AE%97%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.waverley.me/2016/09/04/Jupyter Notebook：交互计算工具/</id>
    <published>2016-09-03T16:40:00.000Z</published>
    <updated>2016-12-21T15:34:07.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">Jupyter Notebook，一个web界面的vim+跨平台+即时运行结果的强大online编辑器。</blockquote>

<p><img src="http://waverley.me/assets/blogImg/jupyterpreview.png" alt="此处输入图片的描述"></p>
<a id="more"></a>
<blockquote>
<p><a href="https://jupyter.org/" target="_blank" rel="external">Jupyter Notebook</a>（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言如Python, R, Julia and Scala。Jupyter Notebook是一个基于WEB的程序，可以用于数据清洗和转换，数值模拟，统计建模，机器学习，数据科学等。</p>
</blockquote>
<ul>
<li>支持运行 超过40种编程语言，如Python, R, Julia and Scala</li>
<li>可用多种方式进行分享，如email, Dropbox, GitHub and the <a href="http://nbviewer.jupyter.org/" target="_blank" rel="external">Jupyter Notebook Viewer</a></li>
<li>可产生丰富的输出，并可以进行可视化实时操作，如图像, 视频, LaTeX, and JavaScript</li>
<li>使用大数据工具Apache Spark，pandas, scikit-learn, ggplot2, dplyr等<br><img src="http://waverley.me/assets/blogImg/jupyter0.png" alt="此处输入图片的描述"></li>
</ul>
<h2 id="一、安装Jupyter-Notebook"><a href="#一、安装Jupyter-Notebook" class="headerlink" title="一、安装Jupyter Notebook"></a>一、安装Jupyter Notebook</h2><p>Jupyter可以运行多种编程语言，然而Jupyter Notebook的安装依赖于Python（Python 2.7，Python 3.3或更高）。<br>官方推荐用 <a href="https://www.continuum.io/downloads" target="_blank" rel="external">Anaconda</a> 进行Python和Jupyter的安装。<br>1、下载相应平台的<a href="https://www.continuum.io/downloads" target="_blank" rel="external">Anaconda</a>并按指示进行安装；<br>2、运行一下命令，启动Jupyter Notebook<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jupyter notebook</div></pre></td></tr></table></figure></p>
<p>对于Python用户，也可用pip进行Jupyter Notebook 的安装<br>1、更新pip到最新版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install --upgrade pip</div></pre></td></tr></table></figure></p>
<p>2、使用如下命令安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install jupyter</div></pre></td></tr></table></figure></p>
<p>3、运行命令，启动Jupyter Notebook<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jupyter notebook</div></pre></td></tr></table></figure></p>
<p>运行上面的命令之后，你将看到类似下面这样的输出：<br><img src="http://waverley.me/assets/blogImg/jupyter1.png" alt="此处输入图片的描述"></p>
<blockquote>
<p>启动jupyter notebook后默认监听于本地8888，如果想外部访问也很简单jupyternotebook–ip=x.x.x.x 这样，任何知道 notebook 地址的人都可以连接到 notebook 进行远程使用。</p>
</blockquote>
<h2 id="二、使用Jupyter-Notebook"><a href="#二、使用Jupyter-Notebook" class="headerlink" title="二、使用Jupyter Notebook"></a>二、使用Jupyter Notebook</h2><p>会在你开启 notebook 的文件夹中启动 Jupyter 主界面，如下：<br><img src="http://waverley.me/assets/blogImg/jupyter2.png" alt="此处输入图片的描述"><br>如果想新建一个 notebook，只需要点击New，选择你希望启动的 notebook 类型即可（这里我只安装了一个python内核）；<br><img src="http://waverley.me/assets/blogImg/jupyter3.png" alt="此处输入图片的描述"><br>在新打开的标签页中，我们会看到 notebook 界面，目前里面什么也没有：<br><img src="http://waverley.me/assets/blogImg/jupyter4.png" alt="此处输入图片的描述"><br>下方截图中看到的是一个代码单元格（code cell），以[ ]开头。在这种类型的单元格中，可以输入任意代码并执行，类似一个在线的Python交互界面。例如，输入1 + 2并按下Shift + Enter；之后，单元格中的代码就会被计算，光标也会被移动动一个新的单元格中，你会得到如下结果：<br><img src="http://waverley.me/assets/blogImg/jupyter5.png" alt="此处输入图片的描述"><br>再次输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(&quot;Hello Jupyter!&quot;)</div></pre></td></tr></table></figure></p>
<p>得到下图结果，但这次没有出现类似Out<a href="https://jupyter.org/" target="_blank" rel="external">2</a>这样的文字。这是因为我们将结果打印出来了，没有返回任何的值：<br><img src="http://waverley.me/assets/blogImg/jupyter6.png" alt="此处输入图片的描述"></p>
<blockquote>
<p>notebook 有一个非常有趣的特性，就是可以修改之前的单元格，对其重新计算，这样就可以更新整个文档了。试着把光标移回第一个单元格，并将1 + 2修改成2 + 3，然后按下Shift + Enter重新计算该单元格。你会发现结果马上就更新成了 5。如果你不想重新运行整个脚本，只想用不同的参数测试某个程式的话，这个特性显得尤其强大。不过，你也可以重新计算整个 notebook，只要点击Cell -&gt; Run all即可。</p>
</blockquote>
<p>Jupyter Notebook的功能显然不止这些，还支持Markdown、LaTex 语法等，可用来编辑在线文档；</p>
<h2 id="三、导出功能"><a href="#三、导出功能" class="headerlink" title="三、导出功能"></a>三、导出功能</h2><p>Jupyter Notebook还有一个强大的特性，就是其导出功能。可以将 notebook 导出为多种格式：</p>
<ul>
<li>HTML</li>
<li>Markdown</li>
<li>ReST</li>
<li>PDF（通过 LaTeX）</li>
<li>Raw Python</li>
</ul>
<blockquote>
<p>导出 PDF 功能，可以让你不用写 LaTex 即可创建漂亮的 PDF 文档。你还可以将 notebook 作为网页发布在你的网站上。甚至，你可以导出为 ReST 格式，作为软件库的文档。</p>
</blockquote>
<h2 id="四、Notebook-Widgets"><a href="#四、Notebook-Widgets" class="headerlink" title="四、Notebook Widgets"></a>四、Notebook Widgets</h2><p>Jupyter Notebook集成了多种部件，如gmaps，Matplotlib等<br>Gmaps是一个数据可视化工具，是Jupyter Notebook的一个嵌入了Google Maps的插件。敬请关注《Gmaps:轻松集成Google Maps的Jupyter Notebook插件》<br>先贴一张图(地震分部热力图)：<br><img src="http://waverley.me/assets/blogImg/jupyter7.png" alt="此处输入图片的描述"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;Jupyter Notebook，一个web界面的vim+跨平台+即时运行结果的强大online编辑器。&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://waverley.me/assets/blogImg/jupyterpreview.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术总结" scheme="http://www.waverley.me/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
      <category term="手册速查" scheme="http://www.waverley.me/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/%E6%89%8B%E5%86%8C%E9%80%9F%E6%9F%A5/"/>
    
    
      <category term="手册" scheme="http://www.waverley.me/tags/%E6%89%8B%E5%86%8C/"/>
    
      <category term="Jupyter Notebook" scheme="http://www.waverley.me/tags/Jupyter-Notebook/"/>
    
      <category term="工具" scheme="http://www.waverley.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Git入门手册</title>
    <link href="http://www.waverley.me/2016/04/16/Git%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/"/>
    <id>http://www.waverley.me/2016/04/16/Git入门手册/</id>
    <published>2016-04-16T06:40:00.000Z</published>
    <updated>2016-12-21T15:34:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。</blockquote>

<p>Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。<br>Git是目前世界上最先进的分布式版本控制系统（没有之一），将Git有关命令记录如下。</p>
<p>安装git</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install git</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>配置git信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name &quot;waverley&quot;</div><div class="line">git config --global user.email &quot;XXX&quot;</div></pre></td></tr></table></figure></p>
<p>初始化一个项目,所有文件都在目录waverley之下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#你可以计划改动(把它们添加到缓存区),使用如下命令:</div><div class="line">git add waverley</div><div class="line">git add *</div><div class="line">git rm file</div><div class="line">git rm -r dir</div><div class="line">#这是 git 基本工作流程的第一步;使用如下命令以实际提交改动:</div><div class="line">git commit -m &quot;代码提交信息&quot;</div><div class="line">#现在,你的改动已经提交到了 HEAD,但是还没到你的远端仓库。</div></pre></td></tr></table></figure></p>
<p>检查都做了哪些修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git diff  #只能查到git add之前的修改文件</div><div class="line">git diff --cached  #可以查到git commit之前的文件</div><div class="line">git status #查看git commit之前都有哪些文件发生了改动</div></pre></td></tr></table></figure></p>
<p>查看提交日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git log</div><div class="line">git log -p #可以查看详细的日志</div></pre></td></tr></table></figure></p>
<p>查看操作记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reflog</div></pre></td></tr></table></figure></p>
<p>创建并管理分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git branch waverley #创建一个叫waverley的分支</div><div class="line">git branch #显示当前都有哪些分支,其中标注*为当前所在分支</div><div class="line">git checkout waverley #将当前分支转移到 waverley 分支</div><div class="line">git commit -a #提交分支</div><div class="line">git merge waverley #将waverley合并到主分支</div></pre></td></tr></table></figure></p>
<p>克隆一个远程仓库到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone  remote_path  local_path</div></pre></td></tr></table></figure></p>
<p>推送改动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#你的改动现在已经在本地仓库的 HEAD中了。执行如下命令以将这些改动提交到远端仓库:</div><div class="line">git push origin master</div><div class="line">#可以把 master 换成你想要推送的任何分支。如果你还没有克隆现有仓库,并欲将你的仓库连接到某个远程服务器,你可以使用如下命令添加:</div><div class="line">git remote add origin &lt;server&gt;;</div><div class="line">#如此你就能够将你的改动推送到所添加的服务器上去了。</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候,master是“默认的”。在其他分支上进行开发,完成后再将它们合并到主分支上。创建一个叫做“feature_x”的分支,并切换过去:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b feature_x</div></pre></td></tr></table></figure></p>
<p>切换回主分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout master</div></pre></td></tr></table></figure></p>
<p>再把新建的分支删掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d feature_x</div></pre></td></tr></table></figure></p>
<p>除非你将分支推送到远端仓库，不然该分支就是不为他人所见的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="更新与合并"><a href="#更新与合并" class="headerlink" title="更新与合并"></a>更新与合并</h2><p>要更新你的本地仓库至最新改动，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git pull</div></pre></td></tr></table></figure></p>
<p>相当于在你的工作目录中，获取(fetch) 并 合并(merge) 远端的改动。<br>要合并其他分支到你的当前分支(例如 master),执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge</div></pre></td></tr></table></figure></p>
<p>这两种情况下,git 都会尝试去自动合并改动。不幸的是,自动合并并非次次都能成功,并可能导致冲突(conflicts)。 这时候就需要你修改这些文件来人肉合并这些冲突了。改完之后,你需要执行如下命令以将它们标记为合并成功:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add</div></pre></td></tr></table></figure></p>
<p>在合并改动之前,也可以使用如下命令查看:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>在软件发布时创建标签,是被推荐的。这是个旧有概念,在SVN中也有。可以执行如下命令以创建一个叫做 1.0.0 的标签:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag 1.0.0 1b2e1d63ff</div></pre></td></tr></table></figure></p>
<p>1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。使用如下命令获取提交 ID:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log</div></pre></td></tr></table></figure></p>
<p>你也可以用该提交 ID 的少一些的前几位,只要它是唯一的。</p>
<hr>
<h2 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h2><p>回退本地修改<br>假如你做错事(自然,这是不可能的),你可以使用如下命令替换掉本地改动:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout --</div></pre></td></tr></table></figure></p>
<p>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件;已添加到缓存区的改动,以及新文件,都不受影响。</p>
<p>回退远端修改<br>假如你想要丢弃你所有的本地改动与提交,可以到服务器上获取最新的版本并将你本地主分支指向到它:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git fetch origin</div><div class="line">git reset --hard origin/master</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>git是一个很好的版本管理工具，将常用命令总结如下图：</p>
<p><img src="http://waverley.me/assets/blogImg/061510341401056.png" alt="此处输入图片的描述"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。&lt;/blockquote&gt;

&lt;p&gt;Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。&lt;br&gt;Git是目前世界上最先进的分布式版本控制系统（没有之一），将Git有关命令记录如下。&lt;/p&gt;
&lt;p&gt;安装git&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sudo apt-get install git&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术总结" scheme="http://www.waverley.me/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
      <category term="手册速查" scheme="http://www.waverley.me/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/%E6%89%8B%E5%86%8C%E9%80%9F%E6%9F%A5/"/>
    
    
      <category term="Git" scheme="http://www.waverley.me/tags/Git/"/>
    
      <category term="手册" scheme="http://www.waverley.me/tags/%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.waverley.me/2016/03/25/hello-world/"/>
    <id>http://www.waverley.me/2016/03/25/hello-world/</id>
    <published>2016-03-25T15:55:00.000Z</published>
    <updated>2016-12-21T15:33:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Hello World</p>
</blockquote>
<p>  花了两天时间搭建了个博客，也算是有了一个属于自己的私有空间了。<br>hexo+github+coding+markdown的方式使用起来也很方便，还申请了自己的域名waverley.me。</p>
<p>现在，我终于可以大声说：Hello World !</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;Hello World&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  花了两天时间搭建了个博客，也算是有了一个属于自己的私有空间了。&lt;br&gt;hexo+github+coding+markdown的方
    
    </summary>
    
      <category term="闲聊" scheme="http://www.waverley.me/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="http://www.waverley.me/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
</feed>
